# encoding: utf-8
#
# Программа, иллюстрирующая работу сборщика мусора и понятие «область видимости»
# переменной, версия 2. Массив горшочков теперь вынесен в отдельный метод.
#
# (с) rubyrush.ru

# Метод, внутри которого идет подсчет горшочков с медом
def count_honeypots
  # Объявим пустой массив honeypots, куда будут собираться все горшочки.
  honeypots = []

  # Снова считаем до 5 миллионов (но уже внутри метода)
  5_000_000.times do |i|
    honeypots << "Honeypot #{i}"
  end

  # Обратите внимание: переменная honeypots объявлена и используется только
  # внутри этого метода, она не является параметром метода и не используется в
  # качестве возвращаемого значения.
  #
  # Это значит, что «область видимости» переменной honeypots ограничена методом
  # count_honeypots и она будет удалена после выхода из метода.
end

# Винни Пух лег спать и пытается заснуть...
puts 'Winnie the Pooh is trying to fall asleep...'

# Вызвали метод, внутри которого посчитали 5 млн. горшочков
count_honeypots

# Задержка, чтобы успеть увидеть изменение памяти в диспетчере задач
sleep 3

# Вызовом специального метода start модуля GC скажем руби: «запусти сборку
# ненужных объектов».
GC.start

# Задержка, чтобы успеть увидеть изменение памяти в диспетчере задач
sleep 3

# Теперь программа будет ждать ввода из консоли, но вместо ввода мы пойдем и
# посмотрим в диспетчере задач, сколько памяти съела наша программа.
puts 'Now check your memory!'
gets

# После вызова метода count_honeypots все объекты этого метода «снаружи» этого
# метода не видны и больше не нужны (метод уже выполнен).
#
# Интерпретатор руби понимает это и старается почистить память от уже ненужных
# горшочков как только памяти в системе начнет не хватать. Мы вызвали метод
# GC.start, чтобы подтолкнуть руби сделать это сразу.
#
# В языке C например, программисту нужно было бы самому чистить память в
# подобных случаях, пользуясь специальными методами.
#
# В зависимости от версии руби и операционной системы — память может убираться
# не сразу, а через какое–то время. Или убираться только небольшой процент
# памяти.
#
# Когда запускаете программу, подождите немного и проследите в диспетчере задач
# (монитор активности или activity monitor в Mac OS) как меняется потребление
# памяти процессом ruby.
