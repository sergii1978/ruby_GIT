# encoding: utf-8
#
# Программа, которая проверяет, является ли введенная строка email
#
# (с) rubyrush.ru

# Этот код необходим только при использовании русских букв на Windows
if Gem.win_platform?
  Encoding.default_external = Encoding.find(Encoding.locale_charmap)
  Encoding.default_internal = __ENCODING__

  [STDIN, STDOUT].each do |io|
    io.set_encoding(Encoding.default_external, Encoding.default_internal)
  end
end

# Создадим регуглярное выражение для «ловли» email-адреса и запишем его в
# переменную email_regexp. Это стандартное выражение, найденное на просторах
# интернета (гуглить «ruby email regexp»). Вот разбор «регулярки» по пунктам.
#
# * ^ — начало строки
#
# * [0-9a-z_+.\-]+ — 1 или более непробельный символ (юзернейм типа). Тут
#   подойдут все цифры, буквы латинского алфавита, символы: подчеркивание, плюс,
#   точка и минус (минус заэкранирован, чтобы отличить от ввода диапазона).
#
# * @ — собачка :)
#
# * [a-z\d\-]+ — аналогично юзернейму, но без подчеркивианий и плюсов, которых
#   не должно быть в домене или поддомене.
#
# * (\.[a-z\d\-]+)* — возможно, будут поддомены (начинаются с точки), но их
#   может и не быть, поэтому в конце выражения в скобках звездочка, которая
#   говорит нам, что то, что внутри скобок может встретиться 0 или более раз.
#
# * \.[a-z]+ — наконец, доменная зона (тоже начинается с точки) и может
#   содержать только буквы латинского алфавита (привет доменам .рф, почту на
#   которых никогда не примет ни один зарубежный сайт).
#
# * $ — конец строки
#
# * /.../i — важно, что мы создаем регулярное выражение, которому плевать на
#   регистр (ключ i), так как все буквы могут быть в верхнем регистре.

email_regexp = /^[a-z\d_+.\-]+@[a-z\d\-]+(\.[a-z\d\-]+)*\.[a-z]+$/i

# Просим пользователя ввести email
puts 'Введите email:'
user_input = gets.encode('UTF-8').chomp

# Проверяем email по регулярке
if user_input.match(email_regexp)
  puts 'Спасибо!'
else
  puts 'Это не email'
end
