# Исключения

Исключение - это допустимая ошибка, возникающая в процессе выполнения программы, прерывающая выполнение до тех пор, пока не ислючение не будет обработано. Если исключение не обрабатывается, то выполнение программы прекращается.

Каждое исключение относится к классу Exception и его производным. Обычно название каждого подкласса, содержит полную информацию о причине возникновения исключения.

Для создания новых типов исключений обычно используются классы StandartError и RuntimeError.

Системные ошибки, имеющие стандартный цифровой код, также относятся к исключениям. Модуль Errno динамически связывает полученные от операционной системы цифровые коды с подклассами Exception. При этом для каждой ошибки создается собственный подкласс `SystemCallError`, на который ссылается константа в модуле Errno. Цифровой код ошибки может быть получен с помощью константы Errno (`Errno::<ErrorKlass>::Errno`).

## Иерархия исключений

+ _Exception_ - базовый класс для всех исключений.

  * _NoMemoryError_ - выделение памяти не может быть выполнено;

      _ScriptError_- базовый класс для ошибок интерпретации;
        + _LoadError_ - файл не может быть загружен;  
          _NotImplemenetedError_ - метод не поддерживается системой;  
          _SyntaxError_ - ошибка в синтаксисе;

      _SecuirityError_ - нарушение требований безопасности;

      _SignalException_ - получение сигнала от системы;
        + _Interrupt_ - сигнал прервать процесс выполнения (обычно Ctrl+C);

      _SystemExit_ - завершение выполнения программы системой;

      _SystemStackError_ - переполнение стека;

      _StandardError_ - базовый класс для стандартных ошибок выполнения;
        + _Math::DomainError_ - объекты не принадлежат области определения функции;  
          _ArgumentError_ - ошибка при передаче аргументов;

          _EncodingError_ - базовый класс для ошибок, связанных с кодировкой;
            + _Encoding::CompatibilityError_ - исходная кодировка не совместима с требуемой;  
              _Encoding::ConverterNotFoundError_ - требуемая кодировка не поддерживается;  
              _Encoding::InvalidByteSequenceError_ - текст содержит некорректные байты;  
              _Encoding::UndefinedConversionError_ - текст содержит неопределенные символы;

          _FiberError_ - ошибка при работе с управляемыми блоками;

          _IOError_ - возникновение ошибки при работе с потоками;
            + _EOFError_ - достигнут конец файла;

          _IndexError_ - индекс не найден;
            + _KeyError_ - ключ не найден;  
              _StopIteration_ - завершение итерации;

          _LocalJumpError_ - блок не может быть выполнен;

          _NameError_ - неизвестный идентификатор;
            + _NoMethodError_ - неизвестный метод;

          _RangeError_ - выход за границы диапазона;
            + _FloatDomainError_ - попытка преобразования констант для определения специальных чисел (NaN и т.д.);

          _RegexpError_ - ошибка в регулярном выражении;

          _RuntimeError_ - универсальный класс для ошибок выполнения;

          _SystemCallError_ - базовый класс для системных ошибок;

          _ThreadError_ - ошибка при работе с процессами;

          _TypeError_ - неправильный тип объекта. Данное исключение также возникает при объявлении наследования для существующего класса;

          _ZeroDivisionError_ - деление целого числа на ноль.

## Методы

### Exception

`::exception( message = nil ) # -> exception`

Используется для создания объекта. Для аргумента вызывается метод `object.to_str`.

`::new( mesage = nil ) # -> exception`

Используется для создания объекта.

`.exception( message = nil ) # -> exception`

Используется для получения нового экземпляра того же класс. Для аргумента вызывается метод `.to_str`.

`.backtrace # -> array`

Используется для получения данных о распространении исключения. Каждый элемент имеет вид:  
`"имя_файла:номер_строки: in 'идентификатор_метода'"`  
или  
`"имя_файла:номер_строки"`

`.set_backtrace(array) # -> array`

Используется для изменения данных о распространении исключения.

`.to_s # -> string`  
Синонимы: `message`

Сообщение об ошибке (или идентификатор класса).

`.inspect # -> string` Идентификатор класса.

### LoadError [ruby 2.0]

`.path # -> string`

Метод используется для получения пути, по которому не был найден файл.

### SignalException

`::new(sig_name) # -> a_signal_exception`

`(sig_number, name = nil)`

Метод используется для создания нового объекта. Название сигнала должно быть известно интерпретатору.

`.signo # -> number`

Метод используется для получения номера сигнала.

### SystemExit

`::new( status = 0 ) # -> exception`

Используется для создания нового объекта.

`.status # -> integer` Статус завершения программы.

`.success? # -> bool`

Проверка удалось ли завершение программы.

### Encoding::InvalidByteSequenceError

`.destination_encoding # -> encoding` Требуемая кодировка

`.destination_encoding_name # -> string` Название требуемой кодировки.

`.source_encoding # -> encoding`

Исходная кодировка. При нескольких преобразованиях исходной будет считаться последняя стабильная кодировка.

`.source_encoding_name # -> string`

Название исходной кодировки. При нескольких преобразованиях исходной будет считаться последняя стабильная кодировка.

`.error_bytes # -> string`

Байт из-за которого возникло исключение.

`.incomplete_input? # -> bool`

Проверка возникновения исключения из-за преждевременного завершения текста.

`.readagain_bytes # -> string`

Байт, обрабатываемый в момент возникновения исключения.

### Encoding::UndefinedConversionError

`.destination_encoding # -> encoding` Требуемая кодировка

`.destination_encoding_name # -> string` Название требуемой кодировки.

`.source_encoding # -> encoding`

Исходная кодировка. При нескольких преобразованиях исходной будет считаться последняя стабильная кодировка.

`.source_encoding_name # -> string`

Название исходной кодировки. При нескольких преобразованиях исходной будет считаться последняя стабильная кодировка.

`.error_char # -> string`

Символ из-за которого возникла ошибка.

### StopIteration

`.result # -> object`
Результат итерации.

### LocalJumpError

`.exit_value # -> object`

Аргумент, передача которого привела к возникновению исключения.

`.reason # -> symbol`

Идентификатор инструкции, выполнение которой привело к возникновению исключения (:break, :redo, :retry, :next, :return, или :noreason).

### NameError

`::new( message, name = nil ) # -> exception`

Используется для создания нового объекта.

`.name # -> name`

Идентификатор, использование которого привело к возникновению исключения.

### NoMethodError

`::new( message, name, *args ) # -> exception`

Используется для создания нового объекта.

`.args # -> object`

Аргументы, переданные отсутствующему методу.

### SystemCallError

`::new( message, integer ) # -> exception`

Используется для создания нового экземпляра класса из модуля Errno (если методу передан известный системе цифровой код ошибки) или класса SystemCallError.

`.errno # -> integer` Цифровой код ошибки.

## Возникновение и обработка исключений

### Вызов исключения

Вызов исключения выполняется с помощью частного метода экземпляров из модуля Kernel.

`.raise( message = nil ) # -> exception`

`( exc = RuntimeError, message = nil, pos = caller ) # -> exception`  
Синонимы: `fail`

Используется для повторного вызова последнего исключения или создания нового ( RuntimeError), если `$!` ссылается на nil.

В другом случае методу передаются любой объект, отвечающий на вызов метода `.exception`, сообщение об ошибке и текущая позиция выполнения программы.

### Обработка исключений

Обработка событий выполняется с помощью предложения rescue, которое может использоваться только в теле предложений begin, def, class, или module.

Исключения обрабатываются в том же порядке, в котором объявляются обработчики. При возникновении исключения интерпретатор останавливает процесс выполнения программы и начинает поиск обработчика, продвигаясь вверх по области вызова.

Если исключения возникло в результате обработки другого исключения, то поиск обработчиков выполняется заново.

После обработки исключения выполнение программы не продолжается.

#### Полный синтаксис

~~~~~ ruby
  begin
    тело_предложения
  rescue
    тело_обработчика
  else
    code
  ensure
    code
  end
~~~~~

+ Тело обработчика выполняется после возникновения исключения в теле предложения. Переменная `$!` при этом ссылается на конкретный экземпляр исключения.

  Чтобы инициализировать локальную переменную используют инструкцию  
  `rescue => локальная_переменная`.

+ По умолчанию обрабатываются экземпляры StandardError и его производных.

  Для ограничения типов обрабатываемых исключений используют инструкцию `rescue class` или `rescue class => локальная_переменная`. Несколько классов разделяются запятыми.

+ Инструкция else выполняется если исключений не получено. При этом исключения, возникшие в теле инструкции не обрабатываются.

+ Инструкция ensure выполняется после выполнения всего предложения. Результат ее выполнения не влияет на результат выполнения предложения (кроме случаев использования инструкций return, break и т.д)

#### Краткий синтаксис:

`код rescue тело_обработчика`

Если в коде будет вызвана ошибка, то выполняется тело обработчика. Обрабатываются только экземпляры StandardError и его производных.

### Catch и Throw

В других языках программирования обработка событий обычно выполняется с помощью пары инструкций catch и throw. В Ruby существуют частные методы экземпляров из модуля Kernel, ведущие себя сходным образом.

`.catch(name = nil) { |name| } # -> object`

Используется для создания прерываемого фрагмента кода. Выполнение останавливается при вызове метода `object.throw` с тем же идентификатором. При вызове без аргументов новый случайный идентификатор передается блоку.

`.throw( name, *args )`

Используется для завершения выполнения блока, переданного методу `object.catch` с тем же идентификатором (иначе возникает исключение). Поиск блока выполняетcя вверх по иерархии области видимости. Дополнительные аргументы возвращаются методом `object.catch`.
