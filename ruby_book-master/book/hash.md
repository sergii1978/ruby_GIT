## Hash (ассоциативные массивы)

`::new( object = nil ) # -> hash`

`{ |hash, key| } # -> hash`

Используется для создания массива с переданным значением по умолчанию.

`::[ key, object ] # -> hash`

`[ *[key,object] ] # -> hash`

`[object] # -> hash`

Используется для создания массива на основе переданных аргументов.

~~~~~ ruby
  Hash[:Ruby, "languages", :Ivan, "man"]
  # -> { Ruby: "languages", Ivan: "man" }

  Hash[ [ [:Ruby, "languages"], [:Ivan, "man"] ] ]
  # -> { Ruby: "languages", Ivan: "man" }

  Hash[Ruby: "languages", Ivan: "man"]
  # -> { Ruby: "languages", Ivan: "man" }
~~~~~

### Приведение типов

`.to_hash # -> hash`

`.to_h # -> self [Ruby 2.0]`

Возвращает объект, для которого был вызван. Когда вызывается для производных классов, получатель преобразуется ассоциативный массив.

`::try_convert(object) # -> hash`

Преобразование объекта в массив, с помощью метода `object.to_hash`. Если для объекта этот метод не определен, то возвращается nil.  
`Hash.try_convert[1] # -> nil`

`.to_s # -> string`  
Синонимы: `inspect`

Преобразование массива в текст. Спецсимволы экранируются.  
`{ a: ?a, "b" => '\n' }.to_s # -> "{:a=>\"a\", \"b\"=>\"\\\\n\"}"`

`.to_a # -> array`

Преобразование ассоциативного массива в индексный вида `[ *[key, object] ]`. Спецсимволы экранируются.  
`{ a: ?a, "b" => '\n' }.to_a # -> [ [:a, "a"], ["b", "\\n"] ]`

### Элементы

`.[key] # -> object`

Используется для получения значения ключа. Если ключ не найден, то возвращается значение по умолчанию.  
`{ a: ?a, "b" => 1 }[:a] # -> "a"`

`.values_at(*key) # -> array`

Используется для получения значений нескольких ключей.  
`{ a: ?a, "b" => 1 }.values_at :a, :b, ?b # ->  ["a", nil, 1]`

`.select { |key, object| } # -> hash`

Используется для получения фрагмента массива, содержащего элементы с положительным результатом итерации.  
`{ a: ?a, "b" => 1 }.select { |key| key == ?b } # -> { "b"=>1 }`

`.key(object) # -> key`

Используется для получения ключа с переданным значением. Если ключ не найден, то возвращается nil.  
`{ a: ?a, "b" => 1 }.key ?a # -> :a`

`.keys # -> array`

Массив ключей.  
`{ a: ?a, "b" => 1 }.keys # -> [:a, "b"]`

`.values # -> array`

Массив значений.  
`{ a: ?a, "b" => 1 }.values # -> [ "a", 1 ]`

`.[key]=(object) # -> object`  
Синонимы: `store`

Используется для изменения содержимого массива.

~~~~~ ruby
  { a: ?a, "b" => 1 }[:a] = 2 # -> 2
  hash # -> { :a => 2, "b" => 1 }
~~~~~

`.fetch( key, default = nil ) # -> object`

`(key) { |key| } # -> object`

Используется для получения значения ключа. Отсутствие ключа считается исключением и может привести либо к остановке выполнения, либо к вычислению блока или дополнительного аргумента.  
`{ a: ?a, "b" => 1 }.fetch :b, ?a # -> "a"`

### Изменение массива

#### Добавление элементов

`.merge(hash) # -> hash2`

`(hash) { |key, self_value, arg_value| } # -> hash2`

Используется для объединения двух массивов. При совпадении ключей предпочтение отдается аргументу или результату выполнения блока.  
`{ a: ?a, "b" => 1 }.merge( { "b" => ?b } ) # -> { a: "a", "b" => "b" }`

`.merge!(hash) # -> self`

`(hash) { |key, self_value, arg_value| } # -> self`  
Синонимы: `update`

Версия предыдущего метода, изменяющая значение объекта.

#### Удаление элементов

`.clear # -> self`

Используется для удаления всех элементов (изменяется значение объекта).  
`{ a: ?a, "b" => 1 }.clear # -> { }`

`.shift # -> array`

Используется для удаления первого элемента (изменяется значение объекта). В результате возвращается индексный массив вида `[key, value]`.  
`{ a: ?a, "b" => 1 }.shift # -> [ :a, "a" ]`

`.delete(key) # -> object`

`(key) { |key| } # -> object`

Используется для удаление заданного элемента (изменяется значение объекта). В результате возвращается значение ключа. Если ключ не найден, то возвращается значение по умолчанию или результат выполнения необязательного блока.

~~~~~ ruby
  { a: ?a, "b" => 1 }.delete :a # -> "a"
  hash # -> { "b"=>1 }
~~~~~

`.delete_if { |key, value| } # -> self`

Используется для удаления всех элементов с положительным результатом итерации (изменяется значение объекта).  
`{ a: ?a, "b" => 1 }.delete_if { |key| key == ?b } # -> { a: "a" }`

`.reject { |key, value| } # -> hash`

Версия предыдущего метода, не изменяющая значение объекта.  
`{ a: ?a, "b" => 1 }.reject { |key| key == ?b } # -> { a: "a" }`

`.reject! { |key, value| } # -> self || nil`

Версия предыдущего метода, изменяющая значение объекта. Если ни один объект не был удален, то возвращается nil.  
`{ a: ?a, "b" => 1 }.reject! { |key| key == ?c } # -> nil`

`.keep_if { |key, value| } # -> self`

Используется для сохранения только элементов с положительным результатом итерации (изменяется значение объекта).  
`{ a: ?a, "b" => 1 }.keep_if { |key| key == ?b } # -> { "b"=>1 }`

`.select! { |key, value| } # -> self`

Версия предыдущего метода, возвращающая nil, если ни один элемент не был удален.  
`{ a: ?a, "b" => 1 }.select! { |key| key == ?b } # -> { "b"=>1 }`

#### Остальное

`.replace(hash) # -> self`  
Синонимы: `initialize_copy`

Используется для замены значения объекта.  
`{ a: ?a, "b" => 1 }.replace( { } ) # -> { }`

`.invert # -> hash`

Используется для смены ключей и их значений местами.  
`{ a: ?a, "b" => 1 }.invert # -> { "a" => :a, 1 => "b" }`

### Предикаты

`.has_key?(key)`  
Синонимы: `include?, key?, member?`

Проверка наличия ключа.  
`{ a: ?a, "b" => 1 }.has_key? :a # -> true`

`.has_value?(object)`  
Синонимы: `value?`

Проверка наличия значения.  
`{ a: ?a, "b" => 1 }.has_value? :a # -> false`

`.compare_by_identity? # -> bool`

Проверка сравниваются ли все ключи по их объектам-идентификаторам.

`.empty? # -> bool`

Проверка отсутствия элементов.  
`{ a: ?a, "b" => 1 }.empty? # -> false`

### Итераторы

`.each { |key, value| } # -> self`  
Синонимы: `each_pair`

Перебор элементов.

`.each_key { |key| } # -> self` Перебор ключей.

`.each_value { |value| } # -> self` Перебор значений.

### Индексные массивы

`.assoc(key) # -> array`

Используется для получения индексного массива, содержащего найденный элемент. Если ключ не найден, то возвращается nil. Сравнение ключей выполняется с помощью оператора `==`.  
`{ a: ?a, "b" => 1 }.assoc :a # -> [:a, "a"]`

`.rassoc(object) # -> array`

Версия предыдущего методы, выполняющая поиск элемента по значению.
`{ a: ?a, "b" => 1 }.rassoc ?a # -> [:a, "a"]`

`.flatten( deep = 0 ) # -> array`

Используется для получения индексного массива, содержащего элементы ассоциативного. Все вложенные индексные массивы будут извлекаться до заданного уровня.

~~~~~ ruby
  { 1 => "one", 2 => [ [2], ["two"] ], 3 => "three" }.flatten 3
  # -> [1, "one", 2, 2, "two", 3, "three"]
~~~~~

### Остальное

`.compare_by_identity # -> self`

Используется для ограничения доступа к элементам с текстовыми ключами.

~~~~~ ruby
  { a: ?a, "b" => 1 }.compare_by_identity
  # -> { :a => "a", "b" => 1 }

  hash[:a] # -> "a"
  hash["b"] # -> nil
  hash[:b] # -> nil
  hash.key 1 # -> "b"
~~~~~

`.size # -> integer`  
Синонимы: `length`

Количество элементов.  
`{ a: ?a, "b" => 1 }.size # -> 2`

`.default # -> object` Значение по умолчанию.

`.default_proc # -> proc`

Подпрограмма, выполняющаяся по умолчанию (или nil).

`.default=(object) # -> object`

Используется для изменения значения по умолчанию.

`.default_proc=(proc) # -> proc`

Используется для изменения подпрограммы, выполняющейся по умолчанию. Аргумент nil отменяет выполнение подпрограммы (Ruby 2.0).

`.hash # -> integer`

Цифровой код объекта.  
`{ a: ?a, "b" => 1 }.hash # -> -3034512`

`.rehash # -> hash` Используется для обновления цифровых кодов ключей.
