## Enumerator (перечни)

Перечни - это составные объекты, содержащие группу элементов и о методе, вызов которого привел к их группировке. Индексация элементов начинается с нуля.

Перечень всех элементов может быть получен с помощью итераторов, которым не был передан блок.

`::new( object, method, *arg ) # -> enum`

`{ |enum| } # -> enum`

Используется для создания перечня. Результат также может быть передан в блок. В теле блока предоставляется возможность добавлять элементы в перечень с помощью выражения `enum << object` (как синоним для yield). Тело блока будет выполняться в момент использования перечня.

~~~~~ ruby
  Enumerator.new( [1, 2, ?R], :delete_at, 2 )
  # -> #<Enumerator: [1, 2, "R"]:delete_at(2)>

  Enumerator.new { |enum| enum << 3 }
  # -> #<Enumerator: <Enumerator::Generator:0x87378e8>:each>
~~~~~

`.enum_for( method = :each, *arg ) # -> enum`  
Синонимы: `to_enum`

Используется для создания перечня элементов текущего составного объекта.  
`[1, 2, ?R].enum_for # -> #<Enumerator: [1, 2, "R"]:each>`

**Во второй версии Ruby** метод принимает блок, с помощью которого может быть вычислен размер перечня (без вычисления его элементов).

~~~~~ ruby
  module Enumerable
    # Дублирование элементов составного объекта.
    def repeat(n)
      raise ArgumentError, "#{n} is negative!" if n < 0
      if block_given?
        each { |*val| n.times { yield *val } }
      else
        # __method__ == :repeat
        enum_for( __method__, n ) { size * n if size }
      end
    end
  end

  enum = (1..14).repeat(3)
  enum.first(4) # -> [1, 1, 1, 2]
  enum.size # -> 42
~~~~~

### Приведение типов

`.inspect # -> string`

Используется для получения информации об объекте.

~~~~~ ruby
  Enumerate.new( [1, 2, ?R], :delete_at, 2 ).inspect
  # -> "#<Enumerator: [1, 2, \"R\"]:delete_at(2)>"
~~~~~

### Элементы перечня

`.next # -> object`

Используется для последовательного доступа к элементам перечня. Достижение конца перечня считается исключением `StopIteration`.

`.next_values # -> array`

Версия предыдущего метода, возвращающая элементы в индексном массиве. Этот метод может быть использован для различия между инструкциями yield и yield nil.

`.peek # -> object`

Используется для получения следующего элемента перечня.  Достижение конца перечня считается исключением `StopIteration`.

`.peek_values # -> array`

Версия предыдущего метода, возвращающая элементы в индексном массиве. Этот метод может быть использован для различия между инструкциями yield и yield nil.

`.rewind # -> enum`

Используется для обнуления позиции последнего извлеченного элемента.

### Итераторы

`.each( start = 0 ) { |object| } # -> self` Перебор элементов.

`.with_index( start = 0 ) { |object, index| } # -> self`

Перебор элементов с их индексами.

`.with_object(object) { |object2, object| } # -> object`

Перебор элементов вместе с дополнительным объектом.

### Остальное

`.feed( object = nil ) # -> nil`

Используется для изменения результата следующей итерации перечня. При вызове без аргументов, использование инструкции yield возвращает nil.

`.size # -> integer [Ruby 2.0]`

Используется для получения размера перечня без вычисления его элементов. Если вычисление невозможно, то возвращается nil.

~~~~~ ruby
  (1..100).to_a.permutation(4).size # -> 94109400
  loop.size # -> Float::INFINITY
  (1..100).drop_while.size # -> nil
~~~~

[](lazy)
### Отложенные вычисления (Enumerator::Lazy)

Класс расширяет понятие перечня (наследует Enemerator).

**Во второй версии Ruby** добавлена возможность откладывать итерацию элементов составного объекта (возможно бесконечного) до того момента как они потребуются.

К сожалению отложенные вычисления обычно медленнее чем обычные, поэтому их применение должно быть оправдано.

`::new( enum, size = nil ) { | yielder, *values | } # -> a_lazy_enum`

Используется для создания объекта. Когда будет вычисляться содержимое перечня, элементы составного объекта будут переданы в блок и смогут быть возвращены в перечень с помощью первого параметра блока.

~~~~~ ruby
  # Принудительное вычисление.
  module Enumerable
    def filter_map(&block)
      map(&block).compact
    end
  end

  # Отложенное вычисление.
  class Enumerator::Lazy
    def filter_map
      Lazy.new(self) do | yielder, *values |
        result = yield *values
        yielder << result if result
      end
    end
  end

  (1..Float::INFINITY).lazy.filter_map{ |i| i*i if i.even? }.first(5)
  # -> [ 4, 16, 36, 64, 100 ]
~~~~~

`.lazy # -> a_lazy_enum`

Используется для создания перечня, позволяющего выполнять отложенные вычисления.

~~~~~ ruby
  [1,2,3].lazy # -> #<Enumerator::Lazy: [1, 2, 3]>
~~~~~

#### Методы

`.force # -> array`  
Синонимы: `to_a`

Используется для принудительного вычисления элементов.

`.collect_concat { |object| } # -> a_lazy_enum`  
Синонимы: `flat_map`

Используется для получения нового перечня, содержащего результаты итерации всех элементов текущего.

~~~~~ ruby
  [ 'foo', 'bar' ].lazy.flat_map { |i| i.each_char.lazy }.force
  # -> [ 'f', 'o', 'o', 'b', 'a', 'r' ]
~~~~~

Результаты итерации будут объединяться в том случае, если они относятся к перечням (отвечают на вызовы методов `.each` и `.force`) или массивам (отвечают на вызов метода `.to_ary`).

~~~~~ ruby
  [ {a:1}, {b:2} ].lazy.flat_map { |i| i }.force
  #=> [ {a:1}, {b:2} ]
~~~~~

`.enum_for( method = :each, *args ) # -> a_lazy_enum`

`( method = :each, *args ) { |*args| } # -> a_lazy_enum`  
Синонимы: `to_enum`

Аналогично соответствующему методу из модуля Kernel. Используется для того, чтобы методы из модуля Enumerable могли возвращать новый вид перечней, если вызываются для объектов подобного типа.

~~~~~ ruby
  r = 1..Float::INFINITY

  # Принудительные вычисления.
  r.repeat(2).first(5) # -> [ 1, 1, 2, 2, 3 ]
  r.repeat(2).class # -> Enumerator
  r.repeat(2).map{ |n| n ** 2 }.first(5) # -> бесконечный цикл!

  # Отложенные вычисления.
  r.lazy.repeat(2).class # -> Enumerator::Lazy
  r.lazy.repeat(2).map{ |n| n ** 2 }.first(5) # -> [ 1, 1, 4, 4, 9 ]
~~~~~

#### Применение

+ Итерация бесконечных объектов;
+ Работа с большими файлами.

~~~~~ ruby
  lines = File.foreach('a_very_large_file')
              .lazy # чтение только необходимой части.
              .select { |line| line.length < 10 }
              .map(&:chomp)
              .each_slice(3)
              .map { |lines| lines.join(';').downcase }
              .take_while { |line| line.length > 20 }

  # Чтение первых трёх строк файла или
  # до тех пор пока длина строки не превысит 20 символов.
  lines.first(3)

  lines.to_a # или...
  lines.force # чтение файла
  lines.each { |elem| puts elem } # и запись каждой строки.
~~~~~
