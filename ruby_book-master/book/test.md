# Тестирование и отладка

## Тестирование

> Если вы хотите улучшить программу, вы должны не тестировать больше, а программировать лучше.

### Основы

Любая, даже самая маленькая программа, не может гарантировать правильной работы. Тестирование программ и исправление обнаруженных ошибок - один из самых трудоемких этапов разработки. Он не заканчивается и после публикации приложения.

Тестирование - это средство обнаружения ошибок. Для поиска и устранения их причин выполняется отладка. Устранение дефектов - это дорогой и длительный процесс. Легче сразу создать высококачественную программу, чем создать низкокачественную и исправлять ее.

Тесты создаются для обнаружения ошибок, которые никогда не должны происходить, в отличии от обработки исключений, возникновение которых возможно и предусмотрено реализацией.

Обзор кода часто эффективнее, чем тестирование, но выполнение тестов позволяет проверить влияние изменений, внесенных в ходе разработки.

Существует множество подходов к тестированию приложения, но в основном грамотное тестирование - процесс прежде всего творческий.

В общем случае тестирование приложения разделяется на четыре уровня:

+ _Модульное тестирование_ - тестирование минимально возможного фрагмента кода (unit test);  
  _Интеграционное тестирование_ - тестирование взаимодействия между различными элементами приложения;  
  _Функциональное тестирование_ - тестирование задач, выполняемых с помощью приложения;  
  _Тестирование производительности_ - тестирование скорости выполнения программы и затрачиваемых на это ресурсов компьютера.

Обычно для облегчения тестирования код разделяют на работающий с проверенными и непроверенными данными.

При выполнении теста ему передаются как заведомо правильные, так и заведомо неправильные данные.

Для тестирования программы может быть использована команда `testrb` (исполняемый файл на Ruby, использующий стандартную библиотеку Test::Unit).

Программа принимает путь к файлу с тестами (или выполняет все тесты в каталоге) и выводит результатаы тестирования.

Для проверки выполнения небольших кусков кода может быть использован интерактивный терминал irb.

### TDD

Одна из популярных техник тестирования - разработка, управляемая тестами (TDD, Test-Drive Development). Использование этой техники разделено на следующие этапы:

+ Написание кода, тестирующего часть приложения;
+ Выполнение теста. Получение отрицательного результата (этот этап необходим для проверки корректности теста);
+ Написание кода приложения;
+ Выполнение теста. Получение положительного результата.

Создание тестов перед кодом фокусирует внимание на требованиях к программе (т.е. необходимо понимание для чего она создается).

Тестирование -> написание кода -> удовлетворение требований -> улучшение кода (рефакторинг).

## Отладка

### Состояние программы

Так как вся программа по сути является объектом, то интроспекция также позволяет узнать о состоянии выполнения программы.

`.global_variables # -> array [PRIVATE: Kernel]`

Идентификаторы глобальных переменных.

`.local_variables # -> array [PRIVATE: Kernel]`

Идентификаторы локальных переменных.

`::constants # -> array [Module]`

Идентификаторы всех констант в теле программы (в теле Object).

`::nesting # -> array [Module]`

Очередь вызовов метода.

`.__method__ # -> symbol [Kernel]`  
Синонимы: `__callee__`

Идентификатор текущего метода. Вне тела метода возвращается nil.

**Во второй версии Ruby** возвращается оригинальное название метода, а не имя синонима.

~~~~~ ruby
  def first; __callee__; end
  first # -> :first

  alias second first
  second # -> :first
~~~~~

##### Переменные и константы

`RUBY_PATCHLEVEL` - версия интерпретатора;

`RUBY_PLATFORM` - название используемой системы;

`RUBY_RELEASE_DATE` - дата выпуска интерпретатора;

`RUBY_VERSION` - версия языка;

`$PROGRAM_NAME ($0)`  - имя выполняемой программы (по умолчанию - имя файла с расширением);

`__dir__` - путь к текущему каталогу (ruby 2.0).

Аналогично `File.dirname __FILE__`;

`__FILE__` - имя выполняемого файла;

`__LINE__` - номер выполняемой строки кода;

`__Encoding__` - кодировка программы.

*****

[](backtrace)
### Стек выполнения

`.caller( offset = 1 ) # -> array [Kernel]`

Состояние стека выполнения в виде массива, содержащего:  
`"файл:строка_кода"` или `"файл: строка_кода in метод"`.

**Во второй версии Ruby** второй аргумент влияет на размер результата. Если он больше, чем количество выполненных строк кода, то возвращается nil.

#### Ruby 2.0

**Во второй версии** добавлен новый способ получить доступ к состоянию стека выполнения программы.

`.caller_locations( start = 1, length = nil ) # -> array or nil [Ruby 2.0]`

`(range) # -> array or nil`

Фрагмент состояния стека выполнения программы в виде массива, содержащего экземпляры `Thread::Backtrace::Location`.

Если начальная позиции фрагмента превышает текущий размер стека, то возвращается nil.

~~~~~ ruby
  # Ruby 1.9:
  def whoze_there_using_caller
    caller[0][/`([^']*)'/, 1]
  end

  # Ruby 2.0:
  def whoze_there_using_locations
    caller_locations(1, 1)[0].label
  end
~~~~~

###### Thread::Backtrace::Location

`.absolute_path # -> string`

Полный путь к файлу.  
`caller_locations.last.absolute_path # -> "/usr/bin/irb"`

`.base_label # -> string`

Основная метка. Обычно соответсвует простой метке без дополнительного оформления.

`caller_locations.last.base_label # -> "main"`

`.inspect # -> string`  
Информация об объекте.

`caller_locations.last.inspect # -> "\"/usr/bin/irb:12:in '<main>'\""`

`.label # -> string`

Метка. Обычно содержит название метода, класса, модуля и т.д. с дополнительным оформлением.  
`caller_locations.last.label # -> "<main>"`

`.lineno # -> integer`

Номер строки кода.  
`caller_locations.last.lineno # -> 12`

`.path # -> string`

Имя файла.

~~~~~ ruby
  loc = caller_locations(0..1).first
  loc.path # -> 'caller_locations.rb'
~~~~

`.to_s # -> string`

Иноформация об объекте в стиле метода `Kernel.caller`.  
`caller_locations.last.to_s # -> "/usr/bin/irb:12:in '<main>'"`

### Трассировка

Трассировка программы может выполняться с помощью частных методов экземпляров из модуля Kernel.

`.set_trace_func( proc = nil )`

Используется для выполнения переданной подпрограммы при возникновении ряда событий. Трассировка в теле подпрограммы при этом не выполняется.

Подпрограмме передаются: идентификатор события, имя файла, номер строки кода, цифровой идентификатор объекта, экземпляр класса Binding и идентификатор класса объекта.

Передача nil отменяет трассировку.

Возможные события:
+ _"c-call"_ - вызов Си функции;  
  _"c-return"_ - завершение выполнения Си функции;  
  _"call"_ - вызов Ruby метода;  
  _"return"_ - завершение выполнения Ruby метода;  
  _"class"_ - начало определения класса или модуля;  
  _"end"_ - завершение определения класса или модуля;  
  _"line"_ - выполнение новой строки кода;  
  _"raise"_ - вызов ошибки.

~~~~~ note
Метод признан устаревшим во второй версии Ruby. Вместо него используется класс TracePoint.
~~~~~

`.trace_var( name, code ) # -> nil`

`(name) { |object| } -> nil`

Используется для выполнения кода при изменении глобальных переменных. В блок передается новое значение.

`.untrace_var( name, code = nil ) # -> array`

Используется для отмены трассировки глобальной переменной. Возвращается массив, содержащий выполняемый при трассировке код.

#### TracePoint (ruby 2.0)

Класс предназначен для замены `Kernel.set_trace_func` в объектном стиле. С помощью его экземпляров можно легко собирать информацию о процессе выполнения программы.

###### Создание трассировщика

`::new(*events) { |a_trace_point| } # -> a_trace_point`

Метод используется для создания объекта. Трассировка не начнется до тех пор пока не будет запущена в явной форме.

По умолчанию будут отслеживаться все доступные события. Для фильтрации событий могут использоваться следующие идентификаторы:

+ _line:_ выполнение новой строки кода;  
  _class:_ начало определения модуля или класса;  
  _end:_ конец определения модуля или класса;  
  _call:_ вызов метода;  
  _return:_ возвращение результата выполнения метода;  
  _c_call:_ вызов Си подпрограммы;  
  _c_return:_ возвращение результата выполнения Си подпрограммы;  
  _raise:_ получение исключения;  
  _b_call:_ начало выполнения блока;  
  _b_return:_ конец выполнения блока;  
  _thread_begin:_ начало выполнения потока;  
  _thread_end:_ конец выполнения блока.

~~~~~ ruby
  trace = TracePoint.new(:call) do |tp|
      p [tp.lineno, tp.defined_class, tp.method_id, tp.event]
  end
  # -> #<TracePoint:0x007f17372cdb20>
~~~~~

+ Отсутствие блока считается исключением ThreadError.

+ Вызов методов, бесполезных для отслеживаемых событий, считается исключением RuntimeError.

~~~~~ ruby
  TracePoint.trace(:line) do |tp|
      p tp.raised_exception
  end
  # -> RuntimeError!
~~~~~

+ Вызов методов вне блока считается исключением RuntimeError.

~~~~~ ruby
  TracePoint.trace(:line) do |tp|
    $tp = tp
  end
  $tp.line # -> RuntimeError!
~~~~~

`::trace(*events) { |a_trace_point| } # -> a_trace_point`

Версия предыдущего метода, автоматически запускающая трассировку.

###### Управление трассировкой

`.enable # -> boolean`

`{ } # -> self`

Метод используется для запуска трассировки. Когда трассировка не выполняется возвращается false.

~~~~~ ruby
  trace.enabled?  # -> false
  trace.enable    # -> false
  trace.enabled?  # -> true
  trace.enable    # -> true
~~~~~

Когда методу передается блок, то трассировка выполняется только в теле блока.

~~~~~ ruby
  trace.enabled? # -> false

  trace.enable do
    trace.enabled?
  end

  trace.enabled? # -> false
~~~~~

`.disable # -> boolean`

`{ } # -> self`

Метод используется для прекращения трассировки. Когда трассировка не выполняется возвращается false.

~~~~~ ruby
  trace.enabled? # -> true
  trace.disable  # -> false
  trace.enabled? # -> false
  trace.disable  # -> false
~~~~~

Когда методу передается блок, то трассировка прекращается только во время выполнения блока.

~~~~~ ruby
  trace.enabled? # -> true

  trace.disable do
    trace.enabled?
  end

  trace.enabled? # -> true
~~~~~

`.enabled? # -> boolean`

Метод используется для проверки статуса активности трассировки.

###### Интроспекция

`.binding # -> a_binding`

Метод используется для сохранения текущего состояния выполнения программы.

`.defined_class # -> a_module`

Метод используется для получения ссылки на класс или модуль (возвращается собственный класс объекта), в котором был вызван обрабатываемый метод. Это позволяет выполнять интроспекцию состояния.

~~~~~ ruby
  class C; def foo; end; end
  trace = TracePoint.new(:call) do |tp|
    p tp.defined_class # -> C
  end.enable do
    C.new.foo
  end
~~~~~

~~~~~ ruby
  module M; def foo; end; end
  class C; include M; end;

  trace = TracePoint.new(:call) do |tp|
    p tp.defined_class # -> M
  end.enable do
    C.new.foo
  end
~~~~~

~~~~~ ruby
  class C; def self.foo; end; end
  trace = TracePoint.new(:call) do |tp|
    p tp.defined_class # -> #<Class:C>
  end.enable do
    C.foo
  end
~~~~~

`.event # -> symbol`

Метод используется для получения типа события.

`.inspect # -> string`

Метод используется для получения текстового сообщения о состоянии объекта.

`.lineno # -> integer`

Метод используется для получения номера строки кода.

`.method_id # -> string`

Метод используется для получения имени вызванного метода.

`.path # -> string`

Метод используется для получения пути к выполняемому файлу.

`.raised_exception # -> an_exception`

Метод используется для получения экземпляра вызванного исключения (только для события `:raise`).

`.return_value # -> object`

Метод используется для получения возвращенного результата (только для событий  `:return`, `:c_return`, `:b_return`).

`.self # -> a_trace_point`

Метод используется для получения трассировщика, отслеживающего событие.
