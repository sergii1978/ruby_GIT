## Array (индексные массивы)

`::new( size = 0, object = nil ) # -> array`

`(array) # -> array`

`(size) { |index| } # -> array`

Используется для создания индексного массива заданного размера. Элементы вычисляются с помощью блока или ссылаются на дополнительный аргумент.

~~~~~ ruby
  Array.new 3, ?R # -> ["R", "R", "R"]
  Array.new [1, 2] # -> [1, 2]
  Array.new(3) { |index| index**2 } # -> [0, 1, 4]
~~~~~

`::[*object] # -> array`

Используется для сохранения объектов в массив.  
`Array[1, 2, 3] # -> [1, 2, 3]`

### Приведение типов

`.to_a # -> array`  
Синонимы: `to_ary`

`::try_convert(object) # -> array`

Преобразование объекта в индексный массив с помощью вызова метода `object.to_ary`. Если для объекта этот метод не определен, то возвращается nil.  
`Array.try_convert 1 # -> nil`

`.to_s # -> string`  
Синонимы: `inspect`

Преобразование массива в текст.  
`[ 1, 2, 3 ].to_s # -> "[1, 2, 3]"`

`.join( sep = $, ) # -> string`

Используется для объединения элементов (join - "объединить", англ.), используя переданный разделитель (по умолчанию nil).

~~~~~ ruby
  [1, 2, 3].join # -> "123"

  [
    "#{msg}",
    "Class: <#{e.class}>",
    "Message: <#{e.message.inspect}>",
    "---Backtrace---",
    "#{MiniTest::filter_backtrace(e.backtrace).join("\n")}",
    "---------------",
  ].join "\n"
~~~~~

`.pack(format) # -> string`

Используется для упаковки массива в двоичный текст, с помощью [apppack](форматной строки).  
`[-1, -2, -3].pack "C*" # -> "\xFF\xFE\xFD"`

### Элементы

Для доступа к элементам используются операторы `[]` и `[]=`. Индексация элементов начинается с нуля. Если индекс отрицательный, то отсчет элементов ведется справа налево, начиная с -1.

~~~~~ note
Наиболее частая проблема с массивами - передача индекса, выходящего за пределы массива.
~~~~~

#### array.[*object]

Синонимы: `slice(*object)`

`.[index] # -> object`  
Синонимы: `at`

Используется для получения элемента с заданным индексом. Если индекс выходит за пределы массива, то возвращается nil.
~~~~~ ruby
  [1, 2, 3][2] # -> 3
  [1, 2, 3][4] # -> nil
~~~~~

`.[start, size] # -> array`

Используется для получения фрагмента массива заданного размера.

* Если количество элементов выходит за пределы массива, то возвращается вся часть массива до последнего элемента;
* Если количество элементов равно нулю, то возвращается ссылка на пустой массив (`[]`);
* Если количество элементов отрицательно, то возвращается nil;
* Если индекс выходит за пределы массива, то возвращается пустой массив.

~~~~~ ruby
  [1, 2, 3][2, 1] # -> [3]
  [1, 2, 3][2, 2] # -> [3]
  [1, 2, 3][2, 0] # -> [ ]
  [1, 2, 3][2, -1] # -> nil
  [1, 2, 3][3, 1] # -> [ ]
~~~~~

`.[range] # -> object`

Используется для получения указанного фрагмента массива.

* Если конечная граница выходит за пределы массива, то возвращается вся часть массива до последнего элемента;
* Если конечная граница меньше, чем начальная, то возвращается пустой массив;
* Если начальная граница выходит за пределы массива, то возвращается nil.

~~~~~ ruby
  [1, 2, 3][1...3] # -> [2, 3]
  [1, 2, 3][1...5] # -> [2, 3]
  [1, 2, 3][1...0] # -> [ ]
  [1, 2, 3][5...9] # -> nil
~~~~~

#### array.[*object]=

Используется для изменения значения объекта. В результате возвращается измененный элемент или массив элементов.

* Превышение конечной границы массива при водит к его расширению. Промежуточные элементы при этом ссылаются на nil.

* Выход за начальную границу массива считается исключением.

`.[index]=(object) # -> object`

Используется для изменения элемента с заданным индексом.

~~~~~ ruby
  [1, 2, 3][2] = "d" # -> "d"
  array # -> [1, 2, "d"]

  [1, 2, 3][4] = "d"  # -> "d"
  array # -> [1, 2, 3, "d"]
~~~~~

`.[start, size]=(object) # -> object`

Используется для изменения фрагмента массива заданного размера.

* Если количество элементов равно нулю, то выполняется вставка элементов.
* Отрицательный размер считается исключением.

~~~~~ ruby
  [1, 2, 3][4, 1] = "d" # -> "d"
  array # -> [1, 2, 3, nil, "d"]

  [1, 2, 3][3, 1] = "d" # -> "d"
  array # -> [1, 2, 3, "d"]

  [1, 2, 3][2, 1] = "d" # -> "d"
  array # -> [1, 2, "d"]

  [1, 2, 3][2, 2] = "d" # -> "d"
  array # -> [1, 2, "d"]

  [1, 2, 3][2, 0] = "d" # -> "d"
  array # -> [1, 2, "d", 3]

  [1, 2, 3][2, -1] = "d" # -> error!
~~~~~

`.[range]=(object) # -> object`

Используется для изменения указанного фрагмента массива. Если конечная граница меньше, чем начальная, то элементы добавляются перед индексом, заданным начальной границей диапазона.

~~~~~ ruby
  [1, 2, 3][1...2] = "d" # -> "d"
  array # ->[1, "d", 3]

  [1, 2, 3][1...5] = "d"# -> "d"
  array # -> [1, "d"]

  [1, 2, 3][1...0] = "d"# -> "d"
  array # -> [1, "d", 2, 3]

  [1, 2, 3][5...9] = "d"# -> "d"
  array # -> [1, 2, 3, nil, nil, "d"]
~~~~~

#### Остальное:

`.fetch(index, object) # -> object2`

`(index) { |index| } # -> object`

Аналогично выполнению `array[index]`. Дополнительный аргумент используется при выходе за пределы массива.  
`[ 1, 2, 3 ].fetch 3, 4 # -> 4`

`.values_at(*object) # -> array`

Аналогично выполнению `array[*object]` для каждого переданного объекта.  
`[ 1, 2, 3 ].values_at 1, 1 # -> [ 2, 2 ]`

`.sample( size = nil ) # -> object`

`( size = nil, random: a_random ) # -> object [Ruby 2.0]`

Используется для получения случайного элемента (или массива случайных элементов). Для пустых массивов возвращается nil или пустой массив соответственно. Если переданный размер равен или превышает размеры исходного массива, то в результате элементы просто перестраиваются в случайном порядке.  
`[ 1, 2, 3 ].sample 4 # -> [ 2, 1, 3 ]`

Необязательный именованный аргумент используется для создания собственного генератора случайных чисел (Ruby 2.0).

`.last(size = 1) # -> object`

Используется для получения последнего элемента или последнего фрагмента.  
`[ 1, 2, 3 ].last 2 # -> [ 2, 3 ]`

`.index(object) # -> integer`

`{ |object| } # -> integer`

Используется для поиска индекса элемента либо равного переданному объекту, либо с положительным результатом выполнения блока.  
`[ 1, 2, 3 ].index { |elem| elem < 3 } # -> 0`

`.rindex(object) # -> integer`

`{ |object| } # -> integer`

Версия предыдущего метода, выполняющая поиск элемента с конца массива.  
`[ 1, 2, 3 ].rindex { |elem| elem < 3 } # -> 1`

### Операторы

`.*(integer) # -> array` Копирование.

`.*(sep) # -> string`

Используется для объединения элементов в текст с использованием переданного разделителя.  
`[1, 2, 3] * ?? # -> "1?2?3"`

`.+(array) # -> new_array` Объединение элементов.

`.-(array) # -> new_array` Удаление элементов.

`.<<(object) # -> self` Добавление элемента. Изменяется значение объекта.

`.&(array) # -> new_array` Пересечение множеств.

`.|(array) # -> array` Объединение множеств.

### Изменение массивов

`.concat(array) # -> self`

Метод используется для добавления в массив переданных элементов. Изменяется значение объекта.

~~~~~ ruby
  [ "a", "b" ].concat [ "c", "d" ] # -> [ "a", "b", "c", "d" ]

  a = [ 1, 2, 3 ]
  a.concat [ 4, 5 ]
  a # -> [ 1, 2, 3, 4, 5 ]
~~~~~

#### Работа со стеком

Стек - это структура данных, предствавляющая из себя список элементов, в котором доступ к следующему элементу может быть получен только после того как был извлечен предыдущий. Стек организуется по принципу LIFO - элемент, который добавлен последним, будет извлекаться самым первым.

В Ruby с любым массивом можно работать как со стеком.

`.push(*object) # -> self`

Метод используется для добавления элементов в конец массива (изменяется значение объекта).

~~~~~ ruby
  a = %w[ a b c ]
  a.push 'd', 'e', 'f' # -> [ 'a', 'b', 'c', 'd', 'e', 'f' ]
  [ 1, 2, 3 ].push(4).push(5) # -> [ 1, 2, 3, 4, 5 ]
~~~~~

`.pop( size = 1 ) # -> object || array`

Используется для удаления элементов из конца массива (изменяется значение объекта). Когда массив пуст, возвращается nil.

~~~~~ ruby
  a = %w[ a b c d ]
  a.pop   # -> 'd'
  a.pop 2 # -> [ 'b', 'c' ]
  a       # -> ['a']
~~~~~

`.unshift(*object) # -> self`

Метод используется для добавления элементов в начало массива (изменяется значение объекта).

~~~~~ ruby
  a = %w[ b c d ]
  a.unshift 'a'  # -> [ 'a', 'b', 'c', 'd' ]
  a.unshift 1, 2 # -> [ 1, 2, 'a', 'b', 'c', 'd' ]
~~~~~

`.shift( size = 1 ) # -> object || array`

Метод используется для удаления элементов из начала массива (изменяется значение объекта). Когда массив пуст, возвращается nil.

~~~~~ ruby
  args = %w[ -m -q filename ]
  args.shift     # -> '-m'
  args           # -> [ '-q', 'filename' ]

  args = %w[ -m -q filename ]
  args.shift 2  # -> [ '-m', '-q' ]
  args           # -> [ 'filename' ]
~~~~~

#### Удаление элементов

`.clear # -> self`

Используется для удаления всех элементов. Изменяет значение объекта.  
`[ 1, 2, 3 ].clear # -> [ ]`

`.compact # -> array`

Используется для удаления элементов, ссылающихся на nil.  
`[ 1, 2, 3 ].compact # -> [ 1, 2, 3 ]`

`.compact! # -> self`

Версия предыдущего метода, изменяющая значение объекта.

`.uniq # -> array`

Используется для удаления повторяющихся элементов.  
`[ 1, 2, 3, 3, 2, 1 ].uniq # -> [ 1, 2, 3 ]`

`.uniq! # -> self`

Версия предыдущего метода, изменяющая значение объекта. Если ни один элемент не был удален, то возвращается nil.

`.slice!(*object) # -> delete`

Используется для удаления фрагментов массива `self[*object]`.  
`[1, 2, 3].slice! 1, 1 # -> [2]`

`.delete(object) # -> removed_object`

`(object) { }`

Используется для удаления всех элементов, равных переданному аргументу (изменяется значение объекта). Если ни один элемент не был удален, то возвращается либо nil, либо результат выполнения необязательного блока.

~~~~~ ruby
  [ 1, 2, 3 ].delete(4) { "error!" } # -> "error!"

  [ 1, 2, 3, 1 ].delete 1 # -> 1
  array # -> [ 2, 3 ]

  array = [ 2, 3, 4 ]
  [ 1, 2, 3 ].each { |elem| array.delete elem } # -> [ 1, 2, 3 ]
  array # -> [4]
~~~~~

`.delete_at(index) # -> delete`

Используется для удаления элемента с заданным индексом (изменяется значение объекта). Если ни один элемент не был удален, то возвращается nil.

~~~~~ ruby
  [1, 2, 3].delete_at 1 # -> 2
  array # -> [1, 3]
~~~~~

`.delete_if { |object| } # -> self`  
Синонимы: `reject!`

Используется для удаления всех элементов с положительным значением итерации (изменяется значение объекта). Если ни один элемент не был удален, то возвращается nil.  
`[1, 2, 3].delete_if { |elem| elem < 3 } # -> [3]`

`.select! { |object| } # -> self`

Используется для сохранения только элементов с положительным значением итерации (изменяется значение объекта). Если ни один элемент не был удален, то возвращается nil.
`[1, 2, 3].select! { |elem| elem < 3 } # -> [1, 2]`

#### Замена элементов

`.replace(array) # -> self`  
Синонимы: `initialize_copy`

Используется для замены значения объекта.  
`[1, 2, 3].replace [ ] # -> [ ]`

`.insert( *(index, *object) ) # -> self`

Аналогично выполнению `array[integer] = *object` для каждой пары переданных методу объектов.  
`[ 1, 2, 3 ].insert 1, 2, 3 # -> [ 1, 2, 3, 2, 3 ]`

`.fill( object, start = 0, size = self.size ) # -> self`

`( start = 0, size = self.size ) { |index| } # -> self`

`( object, range ) # -> self`

`(range) { |index| } # -> self`

Используется для замены всех элементов фрагмента массива заданного размера или диапазона (изменяется значение объекта). Новые объекты либо ссылаются на переданный аргумент, либо вычисляются в результате выполнения блока.  
`[1, 2, 3].fill 1 # -> [1, 1, 1]`

#### Остальное

`.flatten( deep = nil ) # -> array`

Используется для извлечения элементов из вложенных подмассивов до заданного уровня вложенности. По умолчанию извлекаются все элементы.  
`[ [[1]], [[2]], [[3]] ].flatten # -> [1, 2, 3]`

`.flatten!(deep) # -> self` Версия предыдущего метода, изменяющая значение объекта.

`.rotate( step = 1 ) # -> array`

Используется для вращения элементов массива на заданное число позиций - слева направо для положительного аргумента и справа налево для отрицательного.

~~~~~ ruby
  [1, 2, 3].rotate  # -> [2, 3, 1]
  [1, 2, 3].rotate -1  # -> [3, 1, 2]
~~~~~

`.rotate!( step = 1 ) # -> self` Версия предыдущего метода, изменяющая значение объекта.

### Сортировка массива

`.reverse # -> array`

Перестановка элементов в обратном порядке.  
`[1, 2, 3].reverse # -> [3, 2, 1]`

`.reverse! # -> self`

Версия предыдущего метода, изменяющая значение объекта.

`.shuffle # -> array`

`(random: a_random) # -> array [Ruby 2.0]`

Перестановка элементов в случайном порядке. Необязательный аргумент используется для создания собственного генератора случайных чисел (Ruby 2.0).

~~~~~ ruby
  [ 1, 2, 3 ].shuffle # -> [ 2, 3, 1 ]
  [ 1, 2, 3 ].shuffle random: Random.new(1) # -> [ 1, 3, 2 ]
~~~~~

`.shuffle! # -> self`

`(random: a_random) # -> self [Ruby 2.0]`

Версия предыдущего метода, изменяющая значение объекта.

`.sort! # -> self`

`{ |object, object2| } # -> self`

Используется для сортировки элементов (изменяется значение объекта). Элементы сравниваются либо с помощью оператора `<=>`, либо на основе результатов итераций.

`.sort_by! { |object, object2| } # -> self`

Используется для сортировки элементов (изменяется значение объекта) в восходящем порядке на основе результатов итераций.

### Итераторы

`.each { |object| } # -> self` Перебор элементов.

`.each_index { |index| } # -> self` Перебор индексов.

`.collect! { |object| } # -> self`  
Синонимы: `map!`

Используется для замены элементов на результат их итерации (изменяется значение объекта). Часто применяется вместе с функциональным стилем программирования.

~~~~~ ruby
  [1, 2, 3].collect! { |elem| elem + 1 } # -> [2, 3, 4]
  [1, 2, 3].collect! &:to_s # -> ["1", "2", "3"]
~~~~~

`.combination(size) { |array| } # -> self`


Перебор всех возможные фрагментов заданного размера. Различный порядок элементов при этом игнорируется.

+ Если аргумент равен нулю, то итерируется `[[]]`;
+ Если аргумент больше, чем размер объекта, то итерируется пустой массив.

`.repeated_combination(size) { |array| } # -> self`

Версия предыдущего метода, в которой один и тот же элемент может использоваться несколько раз.

`.permutation( size = self.size ) { |array| } # -> self`

Версия метода, учитывающая различный порядок элементов.

`.repeated_permutation( size = self.size ) { |array| } # -> self`

Версия предыдущего метода, в которой один и тот же элемент может использоваться несколько раз.

### Ассоциативные массивы

`.assoc(key) # -> array`

Используется для поиска вложенного подмассива, первый элемент которого равен переданному аргументу. Если совпадений не найдено, то возвращается nil.  
`[ [:a, 1], [:b, 2], [:a, 3] ].assoc :a # -> [:a, 1]`

`.rassoc(object) # -> array`

Используется для поиска вложенного подмассива, второй элемент которого равен переданному аргументу. Если совпадений не найдено, то возвращается nil.  
`[ [:a, 1], [:b, 2], [:a, 3] ].rassoc :a # -> nil`

`.transpose # -> array`

Используется для извлечения из вложенных подмассивов первого и второго элементов. В результате возвращается объект, состоящий из двух вложенных подмассивов. Первый содержит все первые элементы, а второй - оставшиеся элементы.  
`[ [:a, 1], [:b, 1] ].transpose # -> [ [:a, :b], [1, 1] ]`

### Остальное

`.product(*array) # -> array2`

`(*array) { |part| } # -> array3`

Используется для получения всех возможных фрагментов размером self.size, созданных из элементов всех используемых массивов. Учитывается разный порядок элементов. Каждый элемент может быть использован в подмассиве только один раз.

+ При вызове без аргументов, фрагменты будут состоять из одного элемента;
+ Если методу передается пустой массив, то в результате также возвращается пустой массив.

~~~~~ ruby
  [1, 2].product [3] # -> [ [1, 3], [2, 3] ]
  [1, 2, 3].product # -> [ [1], [2], [3] ]
  [1, 2, 3].product [ ] # -> [ ]
~~~~~

`.bsearch { |x| } # -> elem [Ruby 2.0]`

Реализация двоичного поиска (метода деления пополам, дихотомии). Используется для нахождения элемента, который отвечает заданному условию за O(log n), где n - это размер массива. Алгоритм выполняет поиск элемента в отсортированном массиве, используя дробление массива на половины.

Метод реализован как в классическом варианте, так и для использования бисекции. В любом случае массив должен быть монотонным (отсортированным) по отношению к блоку.

+ Поиск элемента

  Блок должен возвращать логическую величину для каждого элемента. Массив должен содержать элемент с индексом i, так что:

  + Блок возвращает false для любого элемента, индекс которого меньше чем i.
  + Блок возвращает true для любого элемента, индекс которого больше или равен i.

  В результате возвращается элемент с индексом i. Когда индекс равен размеру массива, то возвращается nil.

  ~~~~~ ruby
    ary = [0, 4, 7, 10, 12]
    ary.bsearch {|x| x >=   4 } # -> 4
    ary.bsearch {|x| x >=   6 } # -> 7
    ary.bsearch {|x| x >=  -1 } # -> 0
    ary.bsearch {|x| x >= 100 } # -> nil
  ~~~~~

+ Метод бисекции (метод деления отрезка пополам)

  Простейший численный метод для решения нелинейных уравнений вида `F(x) = 0`.

  Блок должен возвращать число для каждого элемента. Массив должен содержать элементы с индексами i и j (`i <= j`), так что:

  + Блок возвращает положительное число для элементов с индексом `0...i`.
  + Блок возвращает ноль для элементов с индексом `i...j`.
  + Блок возвращает отрицательное число для элементов с индексом `j...size`.

  В результате возвращается любой из элементов с индексом из диапазона `i...j`. Если `i == j`, т.е. нет элементов, отвечающих условию, возвращается nil.

  ~~~~~ ruby
    ary = [0, 4, 7, 10, 12]
    # Поиск элемента из диапазона 4...8
    ary.bsearch {|x| 1 - x / 4 } # -> 4 или 7
    # Поиск элемента из диапазона 8...10
    ary.bsearch {|x| 4 - x / 2 } # -> nil
  ~~~~~

`.hash # -> integer`

Цифровой код объекта.  
`[1, 2, 3].hash # -> -831861323`

`.empty? # -> bool`

Проверка пуст ли массив.  
`[1, 2, 3].empty? # -> false`

`.size # -> integer`  
Синонимы: `length`

Количество элементов. Результат всегда на единицу больше, чем индекс последнего элемента.  
`[ 1, 2, 3 ].size # -> 3`
