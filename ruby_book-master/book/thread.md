# Конкуренция и параллелизм

## Основы

Конкуренция в Ruby может быть реализована с помощью потоков выполнения или [сопрограмм](fiber). Параллелизм может быть реализован с помощью процессов.

### Параллелизм

Процесс - максимальная единица планирования ядра ОС. Ресурсы для процессов выделяются системой (каждый процесс использует отдельные ресурсы). При запуске программы создается новый процесс, в пространстве которого она выполняется. В связи с этим процессом также иногда называют непосредственное выполнение кода программы.

Поток выполнения - это минимальная единица планирования. Внутри каждого процесса существует по крайней мере один поток выполнения. Потоки выполнения, находящиеся внутри одного процесса совместно используют его адресное пространство и состояние выполнения.

Каждый раз запуская приложение создается отдельный процесс. Внутри каждого процесса создается основной поток выполнения, в котором выполняется код программы.

~~~~~ note
Потоки выполнения (thread) легко перепутать с потоками данных (io). Поток выполнения - это упорядоченная группа выполняемых действий (инструкций, выражений, команд и т.д.), а поток данных - это упорядоченная группа данных, которые могут быть записаны или прочитаны.
~~~~~

Идея распараллеливания вычислений основана на том, что некоторые задачи (процессы) могут быть разделены на группы меньших задач (потоков выполнения),  выполняющиеся одновременно.

Параллельное программирование включает черты последовательного, но имеет три дополнительных этапа.

+ Разбиение программы на несколько подпрограмм, которые могут выполняться одновременно;
+ Изменение структуры программы для эффективного выполнения подпрограмм;
+ Реализация параллелизма в исходном коде.

Создание программ для параллельного выполнения сложнее, чем для последовательного из-за возникновения конкуренции за ресурсы. Взаимодействие и синхронизация между процессами повышают сложность проектирования параллельных программ.

Параллельные вычисления стали доминирующей парадигмой после появления многоядерных процессоров.

Использование потоков облегчает распараллеливание, так как переключение между потоками легче, чем переключение между процессами, и потоки используют единое адресное пространство. Это обеспечивает быстрый доступ к глобальным данным, но одновременно возникает риск их непреднамеренного искажения (чтобы этого не происходило, необходимо соблюдать некоторую дисциплину программирования).

### Конкуренция

В Ruby реализована поддержка потоков, но при этом применяется глобальная блокировка интерпретатора (GIL), запрещающая выполнение двух или более потоков одновременно. GIL фактически ограничивает параллелизм на многоядерных системах, заменяя его конкуренцией.

Конкуренция - это широко распространенная модель проектирования и выполнения кода, позволяющая нескольким потокам выполняться в рамках одного процесса. Процессор переключается между разными потоками выполнения. Это переключение выполняется достаточно часто, чтобы восприниматься как одновременное выполнение.

Глобальная блокировка необходима, потому что управление памятью в Ruby реализовано в расчете на последовательное выполнение программ и не подразумевает встроенной защиты от изменения различными потоками (а это не безопасно).

Реализация конкуренции в Ruby позволяет реагировать на ввод данных. Обычно если основной поток выполнения заблокирован, то выполнение программы останавливается. Вместо этого, после блокировки основного потока, позволяется переключаться на выполнение производного потока, избегая ожидания реакции системы.

~~~~~ note
Блокировка потока отличается от завершения выполнения. После блокировки выполнение потока может быть продолжено с места выполнения блокировки (точки останова). Таким образом блокировка потока - это ожидание, а не завершение.
~~~~~

### Состояние гонки

Если разные потоки могут изменить одну и ту же переменную, то они потенциально могут достичь состояния гонки. Состояние гонки - одно из главных препятствий параллельного программирования.

Большинство выражений выполняется в несколько операций. Выполнив первую операцию один из потоков может приступить к выполнению следующей операции, в то время как другой поток, выполняя первую операцию, влияет на состояние первого потока.

~~~~~ ruby
  register = i
  register = register + 1
  i = register
~~~~~

В то время как первый поток приступает к третьей операции, второй поток может изменить значение переменной, выполняя вторую операцию.

### Современный параллелизм

Реализация параллелизма в Ruby считается устаревшей на фоне повального распространения многоядерных систем. В других языках программирования существует несколько более современных решений.

+ Атомарные инструкции: превращение выражений в атомарные операции;
+ Транзакционная память (STM): гарантирует что выражения, выполняемые в одной транзакции, будут атомарными (Clojure);
+ Акторы: проектирование кода так, что только один поток может изменять переменную. Выполнение каждого потока в отдельной области видимости, взаимодействие с этими потоками с помощью передачи сообщений (Scala, Erlang).

## Потоки выполнения (Thread)

> Хотя кажется, что потоки выполнения - это небольшой шаг от последовательных вычислений, по сути они представляют собой огромный скачок. Они отказываются от наиболее важных и привлекательных свойств последовательных вычислений: понятности, предсказуемости и детерминизма. Потоки выполнения, как модель вычислений, являются потрясающе недетерминированными, и работа программиста становится одним из обрезков этого недетерминизма.
>: Edward A. Lee

Поток выполнения, создаваемый при запуске программы, называется основным, а потоки выполнения, создаваемые разработчиком - производными.

После завершения основного потока выполнения, процесс выполнения программы прекращается, даже если производные потоки еще не выполнены.

Производные потоки используют ту же глобальную область видимости, что и основной, но многие глобальные переменные отличаются для разных потоков.

Каждый поток операционной системы имеет свой собственный стек, который занимает несколько килобайт памяти, которые, будучи умноженными на количество одновременных соединений, могут занять несколько сот мегабайт. Но если с потерей памяти можно смириться (она стоит дешево), то вычислительные затраты на создание и закрытие потоков, на переключение контекста и на синхронизацию, будут весьма заметны.

Потоки выполнения в Ruby оправдано применять только если существует несколько больших потоков данных (или, в общем, долгое ожидание реакции системы).

~~~~~ note
Потоки могут быть равносильны объектам - они также инкапсулируют некоторое состояние и обмениваются сообщениями для его изменения.
~~~~~

###### Состояние потоков:

+ _Выполняющийся_ - поток, выполнение которого еще не завершено;  
  _Ожидающий_ - поток, бездействующий до выполнения определенного условия (ограничения по времени, получения ответа от системы);  
  _Выполненный_ - поток, выполнение которого завершено. Выполнение может быть завершено нормально, с ошибкой или преждевременно.

Потоки выполнения создаются выполняющимися. Текущий поток выполняется до тех пор пока не будет переведен в режим ожидания или выполнен. После этого начинается выполнение следующего потока. Переключение между потоками совершается при выполнении системных вызовов (например ввода/вывода).

### Thread

Класс Thread реализует стандарт POSIX для реализации потоков выполнения.

`::start(*arg) { |*arg| } # -> thread`  
Синонимы: `fork, new`

Используется для создания нового потока.  
`Thread.start { } # -> #<Thread:0x962817c run>`

`::list # -> array`

Массив, содержащий все созданные потоки выполнения.  
`Thread.list # -> [#<Thread:0x94da0a4 run>, #<Thread:0x964b4d8 sleep>`!

`::current # -> thread`

Текущий поток выполнения.  
`Thread.current # -> #<Thread:0x94da0a4 run>`

`::main # -> thread`

Основной поток выполнения.  
`Thread.main # -> #<Thread:0x94da0a4 run>`

#### Управление текущим потоком

`::pass # -> nil`

Используется для переключения потоков. Переключение выполняется в зависимости от операционной системы и процессора (т.е. не обязательно).  
`Thread.start { Thread.pass } # -> #<Thread:0x962e554 run>`

`::stop # -> nil`

Используется для переключения текущего потока выполнения в режим ожидания.

`::exit # -> thread`  
Cинонимы: `kill`

Используется для завершения выполнения текущего потока. Если выполнение уже завершено, то возвращается ссылка на класс Thread.

#### Управление произвольным потоком

`.join( sec = nil ) # -> thread`

Используется для переключения текущего потока в режим ожидания до тех пор пока не будет выполнен поток, для которого метод был вызван (выполнение потока может быть приостановлено через переданное количество секунд - в этом случае возвращается nil).

~~~~~ ruby
  a = Thread.new { print ?a; sleep(10); print ?b; print ?c }
  x = Thread.new { print ?x; Thread.pass; print ?y; print ?z }
  x.join
  # -> "axyz"

  y = Thread.new { 4.times { sleep 0.1; puts 'tick... ' } }
  puts "Waiting" until y.join 0.15
  # ->
  "tick...
  Waiting
  tick...
  Waiting
  tick...
  tick..."
~~~~~

**Во второй версии Ruby** вызов метода для текущего или основного потоков считается исключением `ThreadError`.

`.value # -> object`

Используется для выполнения потока (с помощью метода `.join`).

`.run  # -> self`

Используется для переключения потока в режим выполнения. Текущий поток при этом переводится в режим ожидания, после чего начинается выполнение процесса, для которого метод был вызван.

`.wakeup # -> self`

Используется для переключения потока в режим выполнения (при этом поток может быть заблокирован).

`.exit(status) # -> self`  
Синонимы: `kill, terminate`

Используется для завершения выполнения потока с переданным статусом. Если выполнение уже завершено, то возвращается ссылка на класс Thread.

`.priority # -> integer`

Приоритет выполнения потока. Основной поток выполняется с нулевым приоритетом. Производные потоки, наследуют приоритет от базовых.

Потоки выполнения с большим приоритетом выполняются раньше, чем потоки с меньшим приоритетом. Работа данного метода зависит от операционной системы.

`.priority=(integer) # -> self`

Используется для изменения приоритета выполнения для потока.

`.add_trace_func( proc = nil ) # -> proc`  
Синонимы: `set_trace_func`

Используется для обработки изменения состояния потока с помощью переданной подпрограммы. Если передается nil, то перехват выполнения прекращается.

#### Локальные переменные

`.[name]=(object) # -> object`

Метод используется для инициализации локальных переменных. Переменные будут существовать только для сопрограмм, выполняемых в теле потока (тело потока считается базовой сопрограммой).

~~~~~ ruby
  [
    Thread.new { Thread.current["name"] = "A" },
    Thread.new { Thread.current[:name]  = "B" },
    Thread.new { Thread.current["name"] = "C" }
  ].each do |th|
    th.join
    puts "#{th.inspect}: #{th[:name]}"
  end

  # ->
  #<Thread:0x00000002a54220 dead>: A
  #<Thread:0x00000002a541a8 dead>: B
  #<Thread:0x00000002a54130 dead>: C
~~~~~
`Thread.main[:local] = 4 # -> 4`

`.[name] # -> object`

Значение локальной переменной. Если переменная не существует, то возвращается nil.  
`Thread.main[:local] # -> 4`

`.keys # -> array`

Массив идентификаторов всех локальных переменных.  
`Thread.main.keys # -> [:local]`

`.key?(name)`

Проверка существования локальной переменной.  
`Thread.main.key? :global # -> false`

###### Ruby 2.0

**Во второй версии** Ruby добавлены методы для работы с локальными переменными потока. В отличии от метода `.[]`, локальные переменные потока будут сохранять свое значение в теле сопрограмм.

`.thread_variable_set(name, value)`

Метод используется для инициализации локальных переменных потока.

`.thread_variable_get(name) # -> value`

Метод используется для получения значения локальной переменной потока.

~~~~~ ruby
  Thread.new {
    Thread.current.thread_variable_set("foo", "bar")
    Thread.current["foo"] = "bar"

    Fiber.new {
      Fiber.yield [
        Thread.current.thread_variable_get("foo"), # -> 'bar'
        Thread.current["foo"],                     # -> nil
      ]
    }.resume
  }.join.value # -> ['bar', nil]
~~~~~

`.thread_variable?(name) # -> bool`

Метод используется для проверки существования локальной переменной потока.

~~~~~ ruby
  me = Thread.current
  me.thread_variable_set(:oliver, "a")
  me.thread_variable?(:oliver)    # -> true
  me.thread_variable?(:stanley)   # -> false
~~~~~

`.thread_variables # -> array`

Метод используется для получения массива имен локальных переменных потока.

~~~~~ ruby
  thr = Thread.new do
    Thread.current.thread_variable_set(:cat, 'meow')
    Thread.current.thread_variable_set("dog", 'woof')
  end
  thr.join               # -> #<Thread:0x401b3f10 dead>
  thr.thread_variables   # -> [:dog, :cat]
~~~~~

#### Обработка ошибок

`::abort_on_exception # -> bool`

Глобальные настройки по обработке исключений. По умолчанию - false.

`::abort_on_exception=(bool) # -> bool`

Используется для применения режима отладки. При получении исключения в любом из производных потоков, выполнение основного потока прекращается. Подобное поведение также применяется если `$DEBUG` ссылается на true (программа запущена с ключом `-d`).

Основной поток завершается с помощью выражения `Thread.main.exit(0)`.

`.abort_on_exception # -> bool`

Глобальные настройки по обработке ошибок. По умолчанию - false.

`.abort_on_exception= (bool) # -> bool`

Используется для применения режима отладки. При получении исключения в любом из производных потоков, выполнение основного потока прекращается. Подобное поведение также применяется если `$DEBUG` ссылается на true (программа запущена с ключом `-d`).

`.raise( message = nil )`

`( exc, message = nil, pos = nil )`

Возбуждение исключения для потока. Метод не может быть вызван для текущего потока выполнения.

#### Асинхронная обработка событий [ruby 2.0]

**Во второй версии Ruby** добавлены методы для асинхронной обработки прерываний. В качестве прерываний рассматриваются исключения (`.raise`), закрытие потока (`.kill`) и закрытие основного потока (все производные потоки также будут закрыты).

`::handle_interrupt(options) { } # -> result`

Метод используется для изменения поведения при обработке прерываний (для текущего потока). Переданный массив содержит классы исключений, ассоциируемые с идентификаторами выполняемых действий. Каждое исключение будет обработано с помощью переданного блока.

##### Действия:

`:immediate` - немедленный вызов прерывания;

`:on_blocking` - вызов прерывания только после блокировки потока;

`:never` - отмена вызова прерывания.

*****

~~~~~ ruby
  # Для основного потока вызов `RuntimeError` будет игнорироваться.
  th = Thread.new do
    Thread.handle_interrupt(RuntimeError => :never) {
      begin
        # You can write resource allocation code safely.
        Thread.handle_interrupt(RuntimeError => :immediate) {
          # ...
        }
      ensure
        # You can write resource deallocation code safely.
      end
    }
  end
  Thread.pass
  # ...
  th.raise "stop"
~~~~~

`::pending_interrupt?(exception_klass = nil) # -> boolean`

Метод используется для проверки существования обработчиков прерываний в очереди (поток ожидает начало обработки прерывания). Когда методу передается аргумент, то проверяются только обработчики определенного класса прерываний.

~~~~~ ruby
  th = Thread.new{
    Thread.handle_interrupt(RuntimeError => :on_blocking){
      loop do
        # ...
        # Безопасная точка для вызова прерывания (поток заблокирован).
        if Thread.pending_interrupt?
          Thread.handle_interrupt(Object => :immediate){}
        end
        # ...
      end
    }
  }
  # ...
  th.raise # остановка потока.
~~~~~

`.pending_interrupt?(exception_klass = nil) # -> boolean`

Версия предыдущего метода для экземпляров класса.

#### Остальное

`.group # -> thgroup`

Группа, в которую входит поток выполнения. Если поток не входит ни в одну из существующих групп, то возвращается nil.  
`Thread.main.group # -> #<ThreadGroup:0x94d9d98>`

`.inspect # -> string`

Информация об объекте.  
`Thread.main.inspect -> "#<Thread:0x94da0a4 run>"`

`.status # -> object`

Статус выполнения потока.

+ _"run"_ - выполняющийся;  
  _"sleep"_ - ожидающий;  
  _false_ - выполненный;  
  _nil_ - выполненный с ошибкой;  
  _"aborting"_ - выполненный преждевремменно;

`Thread.main.status -> "run"`

`.alive? # -> bool`

Проверка будет ли выполняться поток (поток не выполнен).  
`Thread.main.alive? -> true`

`.stop? # -> bool`

Проверка остановлено ли выполнение потока (поток не выполняется).  
`Thread.main.stop? -> false`

`.safe_level # -> integer`

Уровень безопасности.  
`Thread.main.safe_level -> 0`

`.backtrace # -> array`

Состояние выполнения потока.

`.backtrace_locations(*args) # -> array || nil [Ruby 2.0]`

Метод используется для получения [стека выполнения](backtrace) текущего потока. Эквивалентно `.caller_locations`.

### Группировка потоков (ThreadGroup)

Несколько потоков могут быть объединены в одном составном объекте - группе потоков. Каждый поток выполнения может одновременно входить только в одну группу. При добавлении потока в другую группу, он автоматически удаляется из текущей группы. Производные потоки выполнения входят в ту же группу, что и базовые.

`::Default # -> thgroup`

Группа, создаваемая по умолчанию. Основной поток выполнения будет относиться к этой группе.

`::new # -> thgroup`

Используется для создания новой группы.  
`ThreadGroup.new # -> #<ThreadGroup:0x9711728>`

`.add(thread) # -> thgroup`

Используется для добавления потока выполнения в группу.

~~~~~ ruby
  Thread.main.group # -> #<ThreadGroup:0x94d9d98>
  ThreadGroup.new.add Thread.main # -> #<ThreadGroup:0x96f0154>
  Thread.main.group # -> #<ThreadGroup:0x96f0154>
~~~~~

`.enclose # -> thgroup`

Используется для блокирования группы, запрещая добавлять или удалять содержащиеся в ней потоки выполнения.

~~~~~ ruby
  Thread.main.group.enclose # -> #<ThreadGroup:0x96f0154>
  ThreadGroup.new.add Thread.main # -> error
~~~~~

`.enclosed? # -> bool`

Проверка заблокирована ли группа.  
`Thread.main.group.enclosed? # -> true`

`.list # -> array`

Массив потоков выполнения, входящих в группу.

~~~~~ ruby
  Thread.main # -> #<Thread:0x94da0a4 run>
  Thread.main.group.list # -> [#<Thread:0x94da0a4 run>]
~~~~~

### Синхронизация потоков (Mutex)

Синхронизация потоков требуется, чтобы избежать ошибок при использовании потоками одних и тех же данных или устройств (состояние гонки при обновлении данных).

Один из главных принципов безопасного выполнения потоков: изменение общих данных должно выполняться атомарно. К сожалению, в Ruby, для выполнения атомарных операций существует только один механизм синхронизации - блокировка (Mutex - mutual exclusion, взаимное исключение). Блокировка гарантирует, что только один поток способен выполнять этот код в единицу времени.

Многопоточное программирование имеет такую плохую репутацию потому что блокировки очень сложно использовать на практике. Блокировки экспоненциально повышают сложность многопоточного программирования, поэтому Matz рекомендует использовать процессы вместо потоков.

Поток выполнения, который в настоящее время работает с данными, блокирует экземпляр класса Mutex. После выполнения работы, блокировка снимается. В зависимости от наличия блокировки изменяется реакция конкурирующих потоков.

`::new # -> mutex`

Используется для создания нового объекта.

`.lock # -> mutex`

Используется для блокировки. Если объект уже заблокирован текущим потоком, то посылается исключение `ThreadError`.

**Во второй версии Ruby** вызов метода при обработке сигнала (`.trap`) считается исключением `ThreadError`.

`.try_lock # -> bool`

Используется для блокировки объекта. Возвращается результат блокировки.

**Во второй версии Ruby** вызов метода при обработке сигнала (`.trap`) считается исключением `ThreadError`.

`.synchronize # -> bool`

Используется для блокировки объекта во время выполнения блока.

~~~~~ ruby
  @mutex = Mutex.new
  @mutex.synchronize do
    i += 1
  end
~~~~~

**Во второй версии Ruby** вызов метода при обработке сигнала (`.trap`) считается исключением `ThreadError`.

`.locked? # -> bool`

Проверка заблокирован ли объект.

`.owned? # -> bool [Ruby 2.0]`

Был ли объект заблокирован текущим потоком?

`.unlock # -> mutex`

Используется для снятия блокировки. Если объект заблокирован другим потоком выполнения, то посылается исключение `ThreadError`.

**Во второй версии Ruby** вызов метода при обработке сигнала (`.trap`) считается исключением `ThreadError`.

`.sleep( sec = nil ) # -> sec`

Используется для снятия блокировки и переключения в режим ожидания. Если объект заблокирован другим потоком выполнения, то посылается исключение `ThreadError`.

**Во второй версии Ruby** вызов метода при обработке сигнала (`.trap`) считается исключением `ThreadError`.

Также стоит помнить что ожидание может быть завершено до окончания таймера (например в результате получения сигнала).

## Процессы (Process)

### Linux

Процессы бывают системными и пользовательскими, так как все, что происходит в системе может быть запущено либо пользователем, либо ядром.

Процесс init вызывается по окончании загрузки системы и является базовым для всех пользовательских процессов.

Интерактивные процессы связаны с терминалом, посредством которого можно взаимодействовать с процессом (посредством сигналов или ввода/вывода данных).

Демоны (неинтерактивные процессы) не связаны с терминалом и могут взаимодействовать с системой только с помощью сигналов.

Зомби - это процессы, зависшие в режиме ожидания.

###### Свойства процесса:

+ _PID_ - идентификатор процесса;
+ _PPID_ - идентификатор базового процесса;
+ _UID_ - реальный идентификатор владельца (обычно это пользователь, запустивший процесс);
+ _EUID_ - действующий идентификатор владельца.  Определяет права доступа к файлам для процесса;
+ _GUID_ - реальный идентификатор группы владельцев;
+ _EGUID_ - действующий идентификатор группы владельцев. Наследует права доступа для группы, к которой принадлежит запустивший процесс пользователь;
+ имя владельца процесса;
+ приоритет;
+ терминал.

Стадии жизненного цикла процесса:
+ запуск (рождение);
+ выполнение;
+ завершение (смерть);

Вытеснение одной программы другой в рамках единственного процесса - типичный способ запуска новой программы. На самом деле производные процессы - это замещение копий базовых процессов.

### Системные команды

`ps` - системная команда, выводящая информацию о процессах.

Сигналы:
+ Корректное завершение: kill -15 PID или kill -TERM PID
+ Принудительное завершение: kill -9 или kill -KILL

Изменение приоритета:
+ Повышение: nice -5 NAME (по умолчанию 10);
+ Понижение: nice --7 NAME;
+ Изменение: renice 7 PID

Пользователь может управлять только теми процессами, хозяином которых он является, а администратор способен управлять любыми процессами, в том числе и демонами.

### Ruby

Процесс - это программа в стадии ее выполнения. Ruby позволяет манипулировать процессами, используя низкоуровневые возможности системы.

Использование процессов позволяет достигать параллельного выполнения кода на многоядерных системах, но увеличивает сложность программы и количество потребляемой памяти.

`.fork { nil } # -> status`

Используется для выполнения системного вызова, создающего новый процесс, который является копией процесса, выполняющего этот вызов.

+ PID процессов отличаются;
+ PPID производного процесса равен PID базового;
+ Для производного процесса создается собственная таблица файловых дескрипторов, копирующая таблицу базового процесса. Изменения не синхронизируются.

Подпроцессы обычно используются для выполнения системных вызовов exec, загружающих в пространство подпроцесса новую программу. Однако ничто не мешает использовать подпроцессы для выполнение параллельных задач.

В Linux страницы памяти базового процесса копируются производным, только после их изменения. Это позволяет уменьшить время создания процессов и количество потребляемой памяти.

Для производного процесса копируется только текущий поток выполнения.

Переданный блок выполняется в теле производного процесса. После выполнения производного процесса блок закрывается и возвращается 0.

В другом случае код программы после вызова метода, выполняется дважды - для базового процесса и для производного процесса:

+ Для базового процесса в результате вызова метода возвращается идентификатор производного процесса;

+ Для производного процесса в результате вызова метода возвращается nil.

Базовый процесс должен обрабатывать статусы завершения производных процессов с помощью методов `::wait` или `::detach`, иначе процессы могут превратиться в зомби.

Если создание подпроцессов не реализовано для ОС, то выполнение  
`Process.respond_to?(:fork)` вернет false.

`.fork { nil } # -> status [PRIVATE: Kernel]`

Версия предыдущего метода из модуля Kernel.

## Обработка сигналов (Signal)

Сигналы - это способ передачи сообщений между процессами.

`::list # -> hash`

Массив названий сигналов, ассоциируемых с цифровыми кодами.

`::trap( name, command ) # -> object`

`(name) { } # -> object`

Используется для обработки сигнала после его получения. Метод принимает либо название сигнала (приставка SIG может быть пропущена), либо его цифровой код. В результате возвращается предыдущий обработчик.

**Во второй версии Ruby** обработка `:SEGV`, `:BUS`, `:ILL`, `:FPE`, `:VTALRM` считается исключением `ArgumentError`.

###### command:

+ блок, выполняемый при получении сигнала;

+ текст:
  + `"IGNORE" ("SIG_IGN")` - полученный сигнал игнорируется;  
    `"DEFAULT" ("SIG_DFL")` - сигнал обрабатывается как обычно;  
    `"SYSTEM_DEFAULT"` - сигнал обрабатывается в зависимости от операционной системы;  
    `"EXIT" (0)` - завершение выполнения программы.

+ системный вызов:
    + `string` - текст команды для используемой оболочки: по умолчанию в Unix - это `"/bin/sh"`, а в Windows - `ENV["RUBYSHELL"]` или `ENV["COMSPEC"]`;  
      `string, *arg` - текст команды и передаваемые аргументы;  
      `{ [string, first_arg], *arg }` - текст команды, первый аргумент и остальные аргументы.

`.trap( name, command ) # -> object [PRIVATE: Kernel]`

`(name) { } # -> object`

Версия предыдущего метода из модуля Kernel.

`::signame(signo) # -> string [Ruby 2.0]`

Метод используется для получения названия сигнала с переданным номером.

~~~~~ ruby
  Signal.trap("INT") { |signo| puts Signal.signame(signo) }
  Process.kill "INT", 0

  # -> 'INT'
~~~~~

## Событийная модель

Создание процессов очень дорого, поэтому для асинхронного IO лучше использовать потоки выполнения или даже события.

Событийная модель обходит ограничения неблокирующего IO. Такая модель очень хорошо масштабируется вертикально, но не горизонтально. После начала IO поток выполнения приостанавливается. После завершения IO возникает событие.

Событийная модель реализована в \href{http://postrank-labs.github.com/goliath}{Goliath} и \href{http://code.macournoyer.com/thin}{Thin}.

Для реализации событийной модели хорошо подходят сопрограммы. К сожалению при чтении/записи с диска событий о завершении не вызывается (вместо этого обычно используется мультиплексирование).

## Cбор мусора

Для того, чтобы лучше понять особенности реализации сбора мусора, необходимо глубже погрузиться в Си реализацию интерпретатора.

Все объекты хранятся в виде структур RArray, RHash, RFile и т.д. Каждая структура представляет собой набор данных и набор флагов, обрабатываемых интерпретатором. Общее название для всех структур - RValue.

Интерпретатор размещает и организует RValue в массиве, который также называется "куча". Для ускорения создания объектов структуры создаются заранее.

При выполнении произвольной программы, создание нового объекта сводится к поиску доступной структуры.

Проблемы:

+ отсутствие свободных структур;
+ отсутствие необходимости создавать новый объект (можно использовать уже существующий).

Когда свободные структуры заканчиваются запускается сбор мусора. Сборщик мусора освобождает структуры, которые больше не используются в программе (в программе нет ссылок на структуру).

Высокоуровневая работа сборщика мусора:

+ пометка существующих структур - перебор всех переменных и ссылок в программе и пометка соответствующих структур флагом FL_MARK. Помеченные структуры не могут быть удалены или использованы заново;

+ хранение списка не помеченных структур. Все новые объекты сохраняются в структурах из этого списка. При сохранении структура из списка удаляется. Как только структуры заканчиваются (список пуст) начинает работу сборщик мусора. Если все структуры заняты и используются, то создается новая "куча" (фактически за один раз создается 10 "куч").

Основной недостаток такой реализации сборщика в том, что пометка структур вызывает копирование памяти для производных процессов.

Обычно данные базового процесса могут свободно использоваться производными процессами (это позволяет не копировать память и ускоряет создание процессов). При изменении общих данных создаются новые фрагменты памяти. Это позволяет иметь общую "кучу" для нескольких процессов. Пометка структур, к сожалению, считается изменением общих данных, поэтому копирование памяти происходит постоянно.

### Ruby 2.0

Новый алгоритм для сбора мусора называется "Bitmap marking" (битовая маркировка). Алгоритм обещает снизить потребление памяти производными процессами (в особенности на веб-серверах, запускающих несколько копий одного приложения).

Впервые этот алгоритм был реализован в ree (ruby enterprise edition).

Вместо установки флага, создается отдельный массив битов, ссылающийся на структуры. Для каждой кучи создается массив, содержащий набор битов. 1 аналогична флагу FL_MARK.

Алгоритм реализован с помощью заголовков (первая структура в куче), ссылающихся на массив битов.

Это позволяет отмечать все используемые структуры без их действительного изменения (не устанавливая флаги), чтобы ядро могло грамотно распределять память между процессами. При этом маркировка выполняется нерекурсивно, позволяя избежать неожиданного переполнения стека.

Массивы битов конечно изменяются, но они содержат непрерывный поток битов и достаточно малы.

Важная особенность в том, что память, выделяемая для кучи, теперь должна быть согласована. Вместо malloc() вызывается posix_memalign().